// Copyright (c) Microsoft Corporation.
// All rights reserved.
//
// This code is licensed under the MIT License.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package com.microsoft.aad.msal4j;

import com.nimbusds.oauth2.sdk.AuthorizationCode;
import com.nimbusds.oauth2.sdk.AuthorizationCodeGrant;
import com.nimbusds.oauth2.sdk.RefreshTokenGrant;
import com.nimbusds.oauth2.sdk.auth.ClientAuthentication;
import com.nimbusds.oauth2.sdk.token.RefreshToken;
import org.slf4j.Logger;

import javax.net.ssl.SSLSocketFactory;
import java.net.MalformedURLException;
import java.net.Proxy;
import java.net.URI;
import java.net.URL;
import java.util.Collection;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.*;

/**
 * Abstract class containing common API methods and properties.
 */
abstract public class ClientApplicationBase {
    protected Logger log;
    protected ClientAuthentication clientAuthentication;
    protected String clientId;
    private String authority;
    protected AuthenticationAuthority authenticationAuthority;
    private boolean validateAuthority;
    private String correlationId;
    private boolean logPii;
    protected ExecutorService executorService;
    private Proxy proxy;
    private SSLSocketFactory sslSocketFactory;

    public static String DEFAULT_AUTHORITY = "https://login.microsoftonline.com/common/";

    /**
     * Returns Proxy configuration to be used by the context for all network communication.
     *
     * @return Proxy Object
     */
    public Proxy getProxy() { return proxy; }

    /**
     * Returns SSLSocketFactory to be used by the context for all network communication.
     *
     * @return SSLSocketFactory object
     */

    public SSLSocketFactory getSslSocketFactory() { return sslSocketFactory; }

    /**
     * Gets the URL of the authority, or security token service (STS) from which MSAL will acquire security tokens
     * The return value of this property is either the value provided by the developer,
     * or otherwise the value of the DEFAULT_AUTHORITY {@link ClientApplicationBase#DEFAULT_AUTHORITY}
     *
     * @return String value
     */
    public String getAuthority() { return this.authority; }

    /**
     * Gets the Client ID (Application ID) of the application as registered in the application registration portal
     * (portal.azure.com) and as passed in the constructor of the application
     */
    public String getClientId() { return this.clientId; }

    /**
     * Returns logPii - boolean value, which determines
     * whether Pii (personally identifiable information) will be logged in
     *
     * @return boolean value of logPii
     */
    public boolean isLogPii() { return logPii; }

    /**
     * Returns the correlation id configured by the user or generated by the API(random UUID)
     * in case the user does not provide one.
     *
     * @return String value of the correlation id
     */
    public String getCorrelationId() { return correlationId; }

    /**
     * Returns a boolean value telling the application if the authority needs to be verified
     * against a list of known authorities.
     *
     * @return boolean value
     */
    public boolean isValidateAuthority() {
        return this.validateAuthority;
    }

    protected TokenCache tokenCache;

    protected CompletableFuture<AuthenticationResult> acquireToken(
            final AbstractMsalAuthorizationGrant authGrant,
            final ClientAuthentication clientAuth) {

        AcquireTokenByAuthorisationGrantSupplier supplier =
                new AcquireTokenByAuthorisationGrantSupplier(this, authGrant, clientAuth);

        CompletableFuture<AuthenticationResult> future =
                executorService != null ? CompletableFuture.supplyAsync(supplier, executorService)
                                : CompletableFuture.supplyAsync(supplier);
        return future;
    }

    protected static void validateNotBlank(String name, String value) {
        if (StringHelper.isBlank(value)) {
            throw new IllegalArgumentException(name + " is null or empty");
        }
    }

    protected static void validateNotNull(String name, Object obj) {
        if (obj == null) {
            throw new IllegalArgumentException(name + " is null");
        }
    }

    protected static void validateNotEmpty(String name, Set<String> set) {
        if (set == null || set.isEmpty()) {
            throw new IllegalArgumentException(name + " is null or empty");
        }
    }

    /**
     * Acquires security token from the authority using an authorization code
     * previously received.
     *
     * @param scopes scopes of the access request
     * @param authorizationCode The authorization code received from service authorization endpoint.
     * @param redirectUri (also known as Reply URI or Reply URL),
     *                    is the URI at which Azure AD will contact back the application with the tokens.
     *                    This redirect URI needs to be registered in the app registration portal.
     * @return A {@link Future} object representing the
     *         {@link AuthenticationResult} of the call. It contains Access
     *         Token, Refresh Token and the Access Token's expiration time.
     */
    public CompletableFuture<AuthenticationResult> acquireTokenByAuthorizationCode(Set<String> scopes,
                                                                                   String authorizationCode,
                                                                                   URI redirectUri)
    {
        validateNotBlank("authorizationCode", authorizationCode);
        validateNotBlank("redirectUri", authorizationCode);

        MsalOAuthAuthorizationGrant authGrant = new MsalOAuthAuthorizationGrant(
                new AuthorizationCodeGrant(new AuthorizationCode(authorizationCode), redirectUri), scopes);

        return this.acquireToken(authGrant, clientAuthentication);
    }

    /**
     * Acquires a security token from the authority using a Refresh Token
     * previously received.
     *
     * @param refreshToken
     *            Refresh Token to use in the refresh flow.
     * @param scopes scopes of the access request
     * @return A {@link CompletableFuture} object representing the
     *         {@link AuthenticationResult} of the call. It contains Access
     *         Token, Refresh Token and the Access Token's expiration time.
     */
    public CompletableFuture<AuthenticationResult> acquireTokenByRefreshToken(String refreshToken, Set<String> scopes) {
        validateNotBlank("refreshToken", refreshToken);

        final MsalOAuthAuthorizationGrant authGrant = new MsalOAuthAuthorizationGrant(
                new RefreshTokenGrant(new RefreshToken(refreshToken)), scopes);

        return this.acquireToken(authGrant, clientAuthentication);
    }

    AuthenticationResult acquireTokenCommon(AbstractMsalAuthorizationGrant authGrant, ClientAuthentication clientAuth,
                                            ClientDataHttpHeaders headers, AuthenticationAuthority requestAuthority)
            throws Exception {

        if(logPii) {
            log.debug(LogHelper.createMessage(
                    String.format("Using Client Http Headers: %s", headers),
                    headers.getHeaderCorrelationIdValue()));
        }

        URL url = new URL(requestAuthority.getTokenUri());
        AdalTokenRequest request = new AdalTokenRequest(url, clientAuth,
                authGrant, headers.getReadonlyHeaderMap(), this.proxy,
                this.sslSocketFactory);
        AuthenticationResult result = request
                .executeOAuthRequestAndProcessResponse();

        InstanceDiscoveryMetadataEntry instanceDiscoveryMetadata =
                AadInstanceDiscovery.GetMetadataEntry(url, validateAuthority, headers, proxy, sslSocketFactory);

        tokenCache.saveTokens(request, result, instanceDiscoveryMetadata.preferredCache);

        return result;
    }

    /**
     * Returns accounts for which there is an cached SSO (RT token)
     *
     */
    public CompletableFuture<AuthenticationResult> acquireTokenSilently
            (Account account, Set<String> scopes, String authorityUrl, boolean forceRefresh) throws MalformedURLException {

        validateNotNull("account", account);
        validateNotEmpty("scopes", scopes);

        AcquireTokenSilentSupplier supplier =
                new AcquireTokenSilentSupplier
                        (this, clientAuthentication, account, scopes, authorityUrl, forceRefresh);

        CompletableFuture<AuthenticationResult> future =
                executorService != null ? CompletableFuture.supplyAsync(supplier, executorService)
                        : CompletableFuture.supplyAsync(supplier);

        return future;
    }

    /**
     * Returns accounts for which there is an cached SSO (RT token)
     *
     */
    public CompletableFuture<Collection<Account>> getAccounts()
    {
        AccountsSupplier supplier = new AccountsSupplier(this);

        CompletableFuture<Collection<Account>> future =
                executorService != null ? CompletableFuture.supplyAsync(supplier, executorService)
                        : CompletableFuture.supplyAsync(supplier);
        return future;
    }

    /**
     * Remove all credentials from cache related to account
     */
    public CompletableFuture removeAccount(Account account)
    {
        RemoveAccountRunnable runnable = new RemoveAccountRunnable(this, account);

        CompletableFuture<Void> future =
                executorService != null ? CompletableFuture.runAsync(runnable, executorService)
                        : CompletableFuture.runAsync(runnable);
        return future;
    }

    protected static String canonicalizeUri(String authority) {
        authority = authority.toLowerCase();

        if (!authority.endsWith("/")) {
            authority += "/";
        }
        return authority;
    }

    abstract static class Builder<T extends Builder<T>> {
        // Required parameters
        private String clientId;

        // Optional parameters - initialized to default values
        private String authority = DEFAULT_AUTHORITY;
        private AuthenticationAuthority authenticationAuthority;
        private boolean validateAuthority = true;
        private String correlationId = UUID.randomUUID().toString().replace("-", "");
        private boolean logPii = false;
        private ExecutorService executorService;
        private Proxy proxy;
        private SSLSocketFactory sslSocketFactory;
        private ITokenCacheAccessAspect tokenCacheAccessAspect;

        /**
         * Constructor to create instance of Builder of client application
         * @param clientId Client ID (Application ID) of the application as registered
         *                 in the application registration portal (portal.azure.com)
         */
        public Builder(String clientId){
            validateNotBlank("clientId", clientId);
            this.clientId = clientId;
        }

        abstract T self();

        /**
         * Set URL of the authenticating authority or security token service (STS) from which MSAL
         * will acquire security tokens.
         * The default value is {@link ClientApplicationBase#DEFAULT_AUTHORITY}
         * @throws MalformedURLException
         */
        public T authority(String val) throws MalformedURLException {
            authority = canonicalizeUri(val);

            if(AuthenticationAuthority.detectAuthorityType(new URL(authority)) != AuthorityType.AAD){
                throw new IllegalArgumentException("Unsupported authority type");
            }

            authenticationAuthority = new AuthenticationAuthority(new URL(authority));

            return self();
        }

        /**
         * Set a boolean value telling the application if the authority needs to be verified
         * against a list of known authorities.
         * The default value is true.
         */
        public T validateAuthority(boolean val)
        {
            validateAuthority = val;
            return self();
        }

        /**
         *  Set optional correlation id to be used by the API.
         *  If not provided, the API generates a random UUID.
         */
        public T correlationId(String val)
        {
            validateNotBlank("correlationId", val);

            correlationId = val;
            return self();
        }

        /**
         * Set logPii - boolean value, which determines
         * whether Pii (personally identifiable information) will be logged in.
         * The default value is false.
         */
        public T logPii(boolean val)
        {
            logPii = val;
            return self();
        }

        /**
         *  Sets ExecutorService to be used to execute the requests.
         *  Developer is responsible for maintaining the lifecycle of the ExecutorService.
         */
        public T executorService(ExecutorService val)
        {
            validateNotNull("executorService", val);

            executorService = val;
            return self();
        }

        /**
         * Sets Proxy configuration to be used by the client application for all network communication.
         * Default is null and system defined properties if any, would be used.
         */
        public T proxy(Proxy val)
        {
            validateNotNull("proxy", val);

            proxy = val;
            return self();
        }

        /**
         * Sets SSLSocketFactory to be used by the client application for all network communication.
         *
         */
        public T sslSocketFactory(SSLSocketFactory val)
        {
            validateNotNull("sslSocketFactory", val);

            sslSocketFactory = val;
            return self();
        }

        /**
         * Sets ITokenCacheAccessAspect to be used for cache_data persistence.
         *
         */
        public T setTokenCacheAccessAspect(ITokenCacheAccessAspect val)
        {
            validateNotNull("sslSocketFactory", val);

            tokenCacheAccessAspect = val;
            return self();
        }

        abstract ClientApplicationBase build();
    }

    ClientApplicationBase(Builder<?> builder) {
        clientId = builder.clientId;
        authority = builder.authority;
        validateAuthority = builder.validateAuthority;
        correlationId = builder.correlationId;
        logPii = builder.logPii;
        executorService = builder.executorService;
        proxy = builder.proxy;
        sslSocketFactory = builder.sslSocketFactory;
        authenticationAuthority = builder.authenticationAuthority;

        tokenCache = new TokenCache(builder.tokenCacheAccessAspect);
    }
}
